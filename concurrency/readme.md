# concurrency

写在前面，并发是编程中最麻烦的问题之一，其核心是对于共享可变更资源的读写。  
最优的并发问题的解法，是优化算法使其不并发。  
如果实在做不到，就退而求其次尽量减少需要并发的地方，减少并发的粒度。  

接下来我们通过示例需求来学习解决并发的思想和并发工具的使用。

示例需求：
现在我们需要设计一个流程编排工具。  
该工具的前端将会是一块画布，用户可以在画布上拖拽各种元素，可以给元素进行连线，一个元素可以连多条线。  
并且一块画布可以同时有多名用户操作。  
要求用户之间的操作不能相互影响。  
这里指的是并发影响，即不变的资源可以同时读，变化的的元素同时只能有一个人写，变化的元素不能同时让别人读。  
比如：这里有用户 `u1`, `u2` 元素 `a`, `b`, `c` 。使用箭头表示连接方向 `u1 a -> b` 表示u1从a向b连接（这代表b元素会从a元素读数据）。使用 `&` 表示同时发生  
那么有：
```
u1 a -> b & u2 a -> c 无影响，可以操作
u1 a -> b & u2 b -> c 有影响，不能操作
u1 a -> c & u2 b -> c 有影响，不能操作
```

这里有两个问题，一个是一致性问题，一个是并发问题。

我们这里先通过节点的链接，搞定并发问题，使用几种并发模型来实现相关功能。

体会几种处理并发的思想。

然后将其升级到系统的一致性问题。

我们这里约定创建元素时接收到的结构为：
```java
class ItemDTO {
	/** 元素id */
    long id;
    /** 画布id */
	long pid;
	/** x轴位置 */
	double x;
	/** y轴位置 */
	double y;
	/** x轴大小 */
	double width;
	/** y轴大小 */
	double length;
	/** 元素类型 */
	String type;
	/** 元数据 */
	Map<String, String> meta;
	/** 最后更新人id */
    long lastUpdateUid;
    /** 最后更新时间 */
    LocalDateTime lastUpdateTime;
}
```


## java并发工具最佳实践总结

### 存在并发风险的共享变量应该使用原子更新类
推荐，或者说要求必须实用原子操作类。不应该使用其他手段。  
首先这提升了可读性，其次会让看代码的人瞬间意识到这里可能有并发问题。  
同时原子更新内存变量是jvm提供的最优实践，非必要不重复造轮子。  
TODO：介绍原子更新类。

### 多线程的同步应该使用CountDownLatch


想要循序渐进的学习并发，那么我们就从一个个例子入手，跑一跑看看有什么问题，怎么解决。

## 从问题学习java并发工具


